Slip 3 : 

Q2 : 
Write a C program which creates a child process to run linux/ unix command or any user defined
program. The parent process set the signal handler for death of child signal and Alarm signal. If
a child process does not complete its execution in 5 second then parent process kills child process.
->

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

// Child’s signal handlers
void sighup_handler(int signum) {
    printf("Child received SIGHUP signal\n");
}

void sigint_handler(int signum) {
    printf("Child received SIGINT signal\n");
}

void sigquit_handler(int signum) {
    printf("My Papa has Killed me!!!\n");
    exit(0);
}

int main() {
    pid_t pid = fork();

    if (pid < 0) {
        perror("fork failed");
        exit(1);
    }

    if (pid == 0) {
        // Child process
        signal(SIGHUP, sighup_handler);
        signal(SIGINT, sigint_handler);
        signal(SIGQUIT, sigquit_handler);

        while (1) {
            pause();  // Wait for signals
        }
    }
    else {
        // Parent process
        sleep(3);
        kill(pid, SIGHUP);

        sleep(3);
        kill(pid, SIGINT);

        sleep(3);
        kill(pid, SIGHUP);

        sleep(3);
        kill(pid, SIGINT);

        sleep(3);
        kill(pid, SIGQUIT);  // Terminate child
    }

    return 0;
}

slip4 : 

Q.1) Write a C program to find whether a given files passed through command line arguments are
present in current directory or not.

[10 Marks ]
-> 
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf("Usage: %s <file1> <file2> ...\n", argv[0]);
        return 1;
    }

    for (int i = 1; i < argc; i++) {
        if (access(argv[i], F_OK) == 0) {
            printf("✅ File '%s' is present in current directory.\n", argv[i]);
        } else {
            printf("❌ File '%s' is NOT present in current directory.\n", argv[i]);
        }
    }

    return 0;
}



Q.2) Write a C program which creates a child process and child process catches a signal SIGHUP,
SIGINT and SIGQUIT. The Parent process send a SIGHUP or SIGINT signal after every 3
seconds, at the end of 15 second parent send SIGQUIT signal to child and child terminates by
displaying message "My Papa has Killed me!!!”.

-> 
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

// Child signal handlers
void sighup_handler(int signum) {
    printf("Child received SIGHUP\n");
}

void sigint_handler(int signum) {
    printf("Child received SIGINT\n");
}

void sigquit_handler(int signum) {
    printf("My Papa has Killed me!!!\n");
    exit(0);
}

int main() {
    pid_t pid = fork();

    if (pid < 0) {
        perror("fork failed");
        exit(1);
    }

    if (pid == 0) {
        // Child process
        signal(SIGHUP, sighup_handler);
        signal(SIGINT, sigint_handler);
        signal(SIGQUIT, sigquit_handler);

        while (1) {
            pause(); // Wait for signals
        }
    } else {
        // Parent process
        sleep(3);
        kill(pid, SIGHUP);

        sleep(3);
        kill(pid, SIGINT);

        sleep(3);
        kill(pid, SIGHUP);

        sleep(3);
        kill(pid, SIGINT);

        sleep(3);
        kill(pid, SIGQUIT); // Terminate child
    }

    return 0;
}

Slip 5 : 

Q.1) Read the current directory and display the name of the files, no of files in current directory

-> 

#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>

int main() {
    DIR *d;
    struct dirent *dir;
    int count = 0;

    d = opendir(".");   // Open current directory
    if (d == NULL) {
        perror("Unable to open directory");
        return 1;
    }

    printf("Files in current directory:\n");

    while ((dir = readdir(d)) != NULL) {
        // Skip "." and ".."
        if (dir->d_name[0] == '.' && 
           (dir->d_name[1] == '\0' || (dir->d_name[1] == '.' && dir->d_name[2] == '\0')))
            continue;

        printf("%s\n", dir->d_name);
        count++;
    }

    closedir(d);

    printf("\nTotal number of files: %d\n", count);

    return 0;
}


Q.2) Write a C program to create an unnamed pipe. The child process will write following three
messages to pipe and parent process display it.
Message1 = “Hello World”
Message2 = “Hello SPPU”
Message3 = “Linux is Funny”
->

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main() {
    int fd[2];  // fd[0] = read end, fd[1] = write end
    pid_t pid;
    
    // Create pipe
    if (pipe(fd) == -1) {
        perror("Pipe failed");
        return 1;
    }

    pid = fork();

    if (pid < 0) {
        perror("Fork failed");
        return 1;
    }

    if (pid == 0) {
        // Child process
        close(fd[0]);  // Close unused read end

        char *msg1 = "Hello World";
        char *msg2 = "Hello SPPU";
        char *msg3 = "Linux is Funny";

        write(fd[1], msg1, strlen(msg1)+1);  // +1 to include null terminator
        write(fd[1], msg2, strlen(msg2)+1);
        write(fd[1], msg3, strlen(msg3)+1);

        close(fd[1]);  // Close write end
        exit(0);
    }
    else {
        // Parent process
        close(fd[1]);  // Close unused write end

        char buffer[100];

        // Read messages from pipe one by one
        for (int i = 0; i < 3; i++) {
            read(fd[0], buffer, sizeof(buffer));
            printf("Parent received: %s\n", buffer);
        }

        close(fd[0]);  // Close read end
    }

    return 0;
}


Slip 6 : 

Q.1) Display all the files from current directory which are created in particular month
[10 Marks ]

-> 
#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>
#include <sys/stat.h>
#include <time.h>
#include <string.h>

int main() {
    DIR *d;
    struct dirent *dir;
    struct stat fileStat;
    char month_name[10];

    printf("Enter month (Jan, Feb, ..., Dec): ");
    scanf("%s", month_name);

    d = opendir(".");
    if (d == NULL) {
        perror("Unable to open directory");
        return 1;
    }

    printf("\nFiles created in %s:\n", month_name);

    while ((dir = readdir(d)) != NULL) {
        // Skip "." and ".."
        if (dir->d_name[0] == '.')
            continue;

        if (stat(dir->d_name, &fileStat) == -1) {
            perror("stat error");
            continue;
        }

        struct tm *timeinfo = localtime(&fileStat.st_mtime);
        char file_month[4];
        strftime(file_month, sizeof(file_month), "%b", timeinfo); // Get month abbreviation

        if (strcasecmp(file_month, month_name) == 0) {
            printf("%s\n", dir->d_name);
        }
    }

    closedir(d);
    return 0;
}


Q.2) Write a C program to create n child processes. When all n child processes terminates, Display
total cumulative time children spent in user and kernel mode

-> 

#include <stdio.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <sys/resource.h>
#include <unistd.h>

int main() {
    int n;
    printf("Enter number of child processes: ");
    scanf("%d", &n);

    pid_t pid;
    struct rusage usage;
    long total_user_sec = 0, total_user_usec = 0;
    long total_sys_sec = 0, total_sys_usec = 0;

    for (int i = 0; i < n; i++) {
        pid = fork();
        if (pid < 0) {
            perror("Fork failed");
            exit(1);
        }
        if (pid == 0) {
            // Child process: do some work
            for (volatile long j = 0; j < 100000000; j++); // Dummy computation
            exit(0);
        }
    }

    // Parent waits for all children
    for (int i = 0; i < n; i++) {
        wait3(NULL, 0, &usage);
        total_user_sec += usage.ru_utime.tv_sec;
        total_user_usec += usage.ru_utime.tv_usec;
        total_sys_sec += usage.ru_stime.tv_sec;
        total_sys_usec += usage.ru_stime.tv_usec;
    }

    printf("\nTotal cumulative time of all children:\n");
    printf("User time: %ld.%06ld sec\n", total_user_sec, total_user_usec);
    printf("System time: %ld.%06ld sec\n", total_sys_sec, total_sys_usec);

    return 0;
}


Slip 7 : 

Q.1) Write a C Program that demonstrates redirection of standard output to a file

[10 Marks ]
- > 

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>

int main() {
    int fd;

    // Open or create file "output.txt" for writing
    fd = open("output.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd < 0) {
        perror("open failed");
        return 1;
    }

    // Redirect stdout to file
    if (dup2(fd, STDOUT_FILENO) < 0) {
        perror("dup2 failed");
        return 1;
    }

    close(fd); // Close unused file descriptor

    // Now all printf output goes to "output.txt"
    printf("Hello World!\n");
    printf("This text is redirected to a file.\n");

    return 0;
}

Q.2) Implement the following unix/linux command (use fork, pipe and exec system call)
ls –l | wc –l 

->
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    int fd[2];
    pid_t pid1, pid2;

    if (pipe(fd) == -1) {
        perror("pipe failed");
        exit(1);
    }

    pid1 = fork();
    if (pid1 < 0) {
        perror("fork failed");
        exit(1);
    }

    if (pid1 == 0) {
        // First child: ls -l
        close(fd[0]);            // Close unused read end
        dup2(fd[1], STDOUT_FILENO); // Redirect stdout to pipe
        close(fd[1]);

        execlp("ls", "ls", "-l", NULL);
        perror("execlp failed");
        exit(1);
    }

    pid2 = fork();
    if (pid2 < 0) {
        perror("fork failed");
        exit(1);
    }

    if (pid2 == 0) {
        // Second child: wc -l
        close(fd[1]);            // Close unused write end
        dup2(fd[0], STDIN_FILENO);  // Redirect stdin to pipe
        close(fd[0]);

        execlp("wc", "wc", "-l", NULL);
        perror("execlp failed");
        exit(1);
    }

    // Parent closes both ends of pipe
    close(fd[0]);
    close(fd[1]);

    // Wait for both children
    wait(NULL);
    wait(NULL);

    return 0;
}


Slip 8 : 

Q.1) Generate parent process to write unnamed pipe and will read from it
[10 Marks ]
-> 

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main() {
    int fd[2];
    pid_t pid;
    char buffer[100];

    // Create pipe
    if (pipe(fd) == -1) {
        perror("pipe failed");
        return 1;
    }

    pid = fork();
    if (pid < 0) {
        perror("fork failed");
        return 1;
    }

    if (pid == 0) {
        // Child process: read from pipe
        close(fd[1]); // Close unused write end
        read(fd[0], buffer, sizeof(buffer));
        printf("Child read: %s\n", buffer);
        close(fd[0]);
    } else {
        // Parent process: write to pipe
        close(fd[0]); // Close unused read end
        char *message = "Hello from Parent!";
        write(fd[1], message, strlen(message)+1);
        close(fd[1]);
        wait(NULL); // Wait for child
    }

    return 0;
}


Q.2) Write a C program to Identify the type (Directory, character device, Block device, Regular file,
FIFO or pipe, symbolic link or socket) of given file using stat() system call.

-> 

#include <stdio.h>
#include <sys/stat.h>

int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }

    struct stat fileStat;
    if (stat(argv[1], &fileStat) < 0) {
        perror("stat failed");
        return 1;
    }

    printf("File: %s\n", argv[1]);

    if (S_ISREG(fileStat.st_mode))
        printf("Type: Regular file\n");
    else if (S_ISDIR(fileStat.st_mode))
        printf("Type: Directory\n");
    else if (S_ISCHR(fileStat.st_mode))
        printf("Type: Character device\n");
    else if (S_ISBLK(fileStat.st_mode))
        printf("Type: Block device\n");
    else if (S_ISFIFO(fileStat.st_mode))
        printf("Type: FIFO / Pipe\n");
    else if (S_ISLNK(fileStat.st_mode))
        printf("Type: Symbolic link\n");
    else if (S_ISSOCK(fileStat.st_mode))
        printf("Type: Socket\n");
    else
        printf("Type: Unknown\n");

    return 0;
}


slip 10 : 

Q.1) Write a program that illustrates how to execute two commands concurrently with a pipe.
[10 Marks ]
->
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    int fd[2];
    pid_t pid1, pid2;

    if (pipe(fd) == -1) {
        perror("pipe failed");
        exit(1);
    }

    // First child executes "ls -l"
    pid1 = fork();
    if (pid1 < 0) {
        perror("fork failed");
        exit(1);
    }
    if (pid1 == 0) {
        close(fd[0]);              // Close read end
        dup2(fd[1], STDOUT_FILENO); // Redirect stdout to pipe
        close(fd[1]);
        execlp("ls", "ls", "-l", NULL);
        perror("execlp failed");
        exit(1);
    }

    // Second child executes "wc -l"
    pid2 = fork();
    if (pid2 < 0) {
        perror("fork failed");
        exit(1);
    }
    if (pid2 == 0) {
        close(fd[1]);              // Close write end
        dup2(fd[0], STDIN_FILENO); // Redirect stdin from pipe
        close(fd[0]);
        execlp("wc", "wc", "-l", NULL);
        perror("execlp failed");
        exit(1);
    }

    // Parent closes both ends and waits
    close(fd[0]);
    close(fd[1]);
    wait(NULL);
    wait(NULL);

    return 0;
}

Q.2) Generate parent process to write unnamed pipe and will write into it. Also generate child process
which will read from pipe
-> 
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    int fd[2];
    pid_t pid1, pid2;

    if (pipe(fd) == -1) {
        perror("pipe failed");
        exit(1);
    }

    // First child executes "ls -l"
    pid1 = fork();
    if (pid1 < 0) {
        perror("fork failed");
        exit(1);
    }
    if (pid1 == 0) {
        close(fd[0]);              // Close read end
        dup2(fd[1], STDOUT_FILENO); // Redirect stdout to pipe
        close(fd[1]);
        execlp("ls", "ls", "-l", NULL);
        perror("execlp failed");
        exit(1);
    }

    // Second child executes "wc -l"
    pid2 = fork();
    if (pid2 < 0) {
        perror("fork failed");
        exit(1);
    }
    if (pid2 == 0) {
        close(fd[1]);              // Close write end
        dup2(fd[0], STDIN_FILENO); // Redirect stdin from pipe
        close(fd[0]);
        execlp("wc", "wc", "-l", NULL);
        perror("execlp failed");
        exit(1);
    }

    // Parent closes both ends and waits
    close(fd[0]);
    close(fd[1]);
    wait(NULL);
    wait(NULL);

    return 0;
}

Slip 11 :


Q.1) Write a C program to get and set the resource limits such as files, memory associated with a
process [10 Marks ]
->
#include <stdio.h>
#include <stdlib.h>
#include <sys/resource.h>

void print_limit(int resource, const char* name) {
    struct rlimit limit;
    if (getrlimit(resource, &limit) == -1) {
        perror("getrlimit failed");
        return;
    }
    printf("%s: soft = %lu, hard = %lu\n", name, limit.rlim_cur, limit.rlim_max);
}

int main() {
    struct rlimit limit;

    printf("Current Resource Limits:\n");
    print_limit(RLIMIT_NOFILE, "Max open files");
    print_limit(RLIMIT_AS, "Max virtual memory");

    // Set new soft limits (example: reduce max open files to 50)
    limit.rlim_cur = 50;
    limit.rlim_max = 100; // Can’t exceed hard limit
    if (setrlimit(RLIMIT_NOFILE, &limit) == -1) {
        perror("setrlimit failed");
    }

    printf("\nUpdated Resource Limits:\n");
    print_limit(RLIMIT_NOFILE, "Max open files");

    return 0;
}

Q.2) Write a C program that redirects standard output to a file output.txt. (use of dup and open system
call).
->
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>

int main() {
    int fd;

    // Open output.txt for writing
    fd = open("output.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd < 0) {
        perror("open failed");
        exit(1);
    }

    // Redirect stdout to file
    if (dup2(fd, STDOUT_FILENO) < 0) {
        perror("dup2 failed");
        exit(1);
    }
    close(fd); // Close original file descriptor

    // All printf outputs now go to output.txt
    printf("This text is redirected to output.txt\n");
    printf("Hello World!\n");

    return 0;
}

Slip 12 : 

Q.1) Write a C program that print the exit status of a terminated child process

[10 Marks ]
->


Q.2) Write a C program which receives file names as command line arguments and display those
filenames in ascending order according to their sizes. I) (e.g $ a.out a.txt b.txt c.txt, ...)

->

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <string.h>

int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf("Usage: %s <file1> <file2> ...\n", argv[0]);
        return 1;
    }

    int n = argc - 1;
    char *files[n];
    off_t sizes[n];

    // Store filenames and sizes
    for (int i = 0; i < n; i++) {
        struct stat st;
        if (stat(argv[i+1], &st) == -1) {
            perror(argv[i+1]);
            sizes[i] = -1;
        } else {
            sizes[i] = st.st_size;
        }
        files[i] = argv[i+1];
    }

    // Bubble sort by size
    for (int i = 0; i < n-1; i++) {
        for (int j = 0; j < n-i-1; j++) {
            if (sizes[j] > sizes[j+1]) {
                // Swap sizes
                off_t temp_size = sizes[j];
                sizes[j] = sizes[j+1];
                sizes[j+1] = temp_size;

                // Swap filenames
                char *temp_file = files[j];
                files[j] = files[j+1];
                files[j+1] = temp_file;
            }
        }
    }

    // Print sorted filenames
    printf("Files in ascending order of size:\n");
    for (int i = 0; i < n; i++) {
        if (sizes[i] >= 0)
            printf("%s (%ld bytes)\n", files[i], sizes[i]);
    }

    return 0;
}

Slip 13 : 

Q.1) Write a C program that illustrates suspending and resuming processes using signals
[10 Marks ]
->
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>

int main() {
    pid_t pid = fork();

    if (pid < 0) {
        perror("fork failed");
        exit(1);
    }

    if (pid == 0) {
        // Child process
        int i = 0;
        while (1) {
            printf("Child running: %d\n", i++);
            sleep(1);
        }
    } else {
        // Parent process
        sleep(3);
        printf("Parent suspending child...\n");
        kill(pid, SIGSTOP);  // Suspend child

        sleep(5);
        printf("Parent resuming child...\n");
        kill(pid, SIGCONT);  // Resume child

        sleep(5);
        printf("Parent terminating child...\n");
        kill(pid, SIGKILL);  // Kill child

        wait(NULL);
        printf("Child terminated.\n");
    }

    return 0;
}

Q.2) Write a C program that a string as an argument and return all the files that begins with that name
in the current directory. For example > ./a.out foo will return all file names that begins with foo
->

#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>
#include <string.h>

int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf("Usage: %s <prefix>\n", argv[0]);
        return 1;
    }

    char *prefix = argv[1];
    size_t len = strlen(prefix);

    DIR *d = opendir(".");
    if (!d) {
        perror("opendir failed");
        return 1;
    }

    struct dirent *dir;
    printf("Files beginning with '%s':\n", prefix);
    while ((dir = readdir(d)) != NULL) {
        if (strncmp(dir->d_name, prefix, len) == 0) {
            printf("%s\n", dir->d_name);
        }
    }

    closedir(d);
    return 0;
}


Slip 14 : 

Q.1) Display all the files from current directory whose size is greater that n Bytes Where n is accept
from user. [10 Marks ]
->

#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>
#include <sys/stat.h>

int main() {
    long n;
    printf("Enter minimum file size in bytes: ");
    scanf("%ld", &n);

    DIR *d = opendir(".");
    if (!d) {
        perror("opendir failed");
        return 1;
    }

    struct dirent *dir;
    struct stat st;

    printf("\nFiles greater than %ld bytes:\n", n);
    while ((dir = readdir(d)) != NULL) {
        if (dir->d_name[0] == '.') continue; // skip hidden files

        if (stat(dir->d_name, &st) == -1) {
            perror("stat failed");
            continue;
        }

        if (st.st_size > n) {
            printf("%s (%ld bytes)\n", dir->d_name, st.st_size);
        }
    }

    closedir(d);
    return 0;
}

Q.2) Write a C program to find file properties such as inode number, number of hard link, File
permissions, File size, File access and modification time and so on of a given file using stat()
system call.
->
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <time.h>

int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }

    struct stat st;
    if (stat(argv[1], &st) == -1) {
        perror("stat failed");
        return 1;
    }

    printf("File: %s\n", argv[1]);
    printf("Inode number: %lu\n", st.st_ino);
    printf("Number of hard links: %lu\n", st.st_nlink);
    printf("File size: %ld bytes\n", st.st_size);

    printf("File permissions: ");
    printf( (S_ISDIR(st.st_mode)) ? "d" : "-");
    printf( (st.st_mode & S_IRUSR) ? "r" : "-");
    printf( (st.st_mode & S_IWUSR) ? "w" : "-");
    printf( (st.st_mode & S_IXUSR) ? "x" : "-");
    printf( (st.st_mode & S_IRGRP) ? "r" : "-");
    printf( (st.st_mode & S_IWGRP) ? "w" : "-");
    printf( (st.st_mode & S_IXGRP) ? "x" : "-");
    printf( (st.st_mode & S_IROTH) ? "r" : "-");
    printf( (st.st_mode & S_IWOTH) ? "w" : "-");
    printf( (st.st_mode & S_IXOTH) ? "x" : "-");
    printf("\n");

    printf("Last access time: %s", ctime(&st.st_atime));
    printf("Last modification time: %s", ctime(&st.st_mtime));
    printf("Last status change time: %s", ctime(&st.st_ctime));

    return 0;
}


